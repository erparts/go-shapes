//kage:unit pixels
package main

// sin(t), cos(t), where t is half the angle of the aperture.
// t = 0 is right, t = pi/2 is down and so on
var WedgeNormal vec2
var InRadius float
var Rounding float

func Fragment(targetCoords vec4, _ vec2, color vec4, customVAs vec4) vec4 {
	const AAMargin = 1.333

	center := customVAs.xy
	centerDir := customVAs.z
	outRadius := customVAs.w

	relCoords := targetCoords.xy - imageDstOrigin()
	relCenterCoords := relCoords - center

	p := rotate(relCenterCoords, -centerDir)
	dist := sdfRingSector(p, WedgeNormal, InRadius, outRadius, Rounding)
	alpha := 1.0 - smoothstep(-AAMargin, 0.0, dist)
	return color * pow(alpha, 1.0/2.2)
}

// rounding must be negative for inner rounding, positive for outer rounding
func sdfRingSector(pos vec2, wedgeNormal vec2, inRadius, outRadius, rounding float) float {
	inRounding, outRounding := -min(rounding, 0.0), max(rounding, 0.0)
	outRadius -= inRounding
	inRadius += inRounding

	pos = pos.yx // switch symmetry axis from original function
	pos.x = abs(pos.x)
	lenPos := length(pos)
	l := max(lenPos-outRadius, inRadius-lenPos)

	// TODO: failed to do inRounding for the side edges
	// pos.y -= inRounding / wedgeNormal.x
	// m is sdSegment(pos, wedgeNormal*inRadius, wedgeNormal*outRadius)
	m := length(pos - wedgeNormal*clamp(dot(pos, wedgeNormal), inRadius, outRadius))
	m *= sign(wedgeNormal.y*pos.x - wedgeNormal.x*pos.y)
	return max(l, m) - inRounding - outRounding
}

func rotate(p vec2, rads float) vec2 {
	cosR, sinR := cos(rads), sin(rads)
	return vec2(p.x*cosR-p.y*sinR, p.x*sinR+p.y*cosR)
}
