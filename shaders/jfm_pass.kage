//kage:unit pixels
package main

// This file implements a single JFA (jump flooding algorithm) pass in Kage.
// The whole algorithm consists of initialization, loop of passes and finalization.
//
// Given Ebitengine's limitations in terms of texture formats, the data for the
// JF internal maps is encoded as follows:
//  - vec4(1) represents a pixel with an unknown/max seed offset. Decoding this
//    value with jfaComputeOffsetToSeed gives a distance of (-32767, -32767). Users
//    should not be allowed to request distances beyond 32k.
//  - vec4(0) represents a seed pixel. Decoding this value with jfaComputeOffsetToSeed
//    gives a distance of (0, 0) (offset to nearest seed is zero).
//  - Otherwise the (R G B A) values are used to encode the offset to the nearest seed.
//    In particular, (R G) represents the x offset and (B A) represents the y offset.
//    The encoding is simply 16 bits: top bit represents sign (0 positive, 1 negative),
//    and the remaining 15 bits represent the magnitude. See jfaDecodeAxisOffsetToSeed
//    and jfaEncodeAxisOffsetToSeed for the actual code.
// Due to this encoding, the algorithm supports a max distinguishable seed offset of +/-32511.
// This also means the largest jump worth starting at is 16384 (meaning 1 + log2(16384) = 15
// passes) (successive passes can find offsets > 16384, up to the next pow2 - 1)

func Fragment(targetCoords vec4, sourceCoords vec2, _ vec4, customVAs vec4) vec4 {
	pix := imageSrc0At(sourceCoords)
	if pix == vec4(0) {
		return vec4(0) // already a seed
	}

	jump := int(customVAs[0])
	maxOffset := int(customVAs[1])
	bestOffset := jfaComputeOffsetToSeed(pix)
	initOffset := bestOffset
	bestDist := sqDist(bestOffset) // if pix is max_offset/uninitialized, bestDist = 2*(32767^2) (expect precision loss)

	offsets := [8]ivec2{
		ivec2(-jump, -jump), ivec2(0, -jump), ivec2(+jump, -jump),
		ivec2(-jump, 0), ivec2(+jump, 0),
		ivec2(-jump, +jump), ivec2(0, +jump), ivec2(+jump, +jump),
	}
	var neighbours [8]vec4
	srcOrigin := imageSrc0Origin()
	srcMax := srcOrigin + imageSrc0Size() - vec2(0.001)

	neighbours[0] = imgSrc0AtOrWhite(sourceCoords+vec2(offsets[0]), srcOrigin, srcMax)
	neighbours[1] = imgSrc0AtOrWhite(sourceCoords+vec2(offsets[1]), srcOrigin, srcMax)
	neighbours[2] = imgSrc0AtOrWhite(sourceCoords+vec2(offsets[2]), srcOrigin, srcMax)
	neighbours[3] = imgSrc0AtOrWhite(sourceCoords+vec2(offsets[3]), srcOrigin, srcMax)
	neighbours[4] = imgSrc0AtOrWhite(sourceCoords+vec2(offsets[4]), srcOrigin, srcMax)
	neighbours[5] = imgSrc0AtOrWhite(sourceCoords+vec2(offsets[5]), srcOrigin, srcMax)
	neighbours[6] = imgSrc0AtOrWhite(sourceCoords+vec2(offsets[6]), srcOrigin, srcMax)
	neighbours[7] = imgSrc0AtOrWhite(sourceCoords+vec2(offsets[7]), srcOrigin, srcMax)

	for i := 0; i < 8; i++ {
		neighbour := neighbours[i]
		offset := jfaComputeOffsetToSeed(neighbour)
		offset += offsets[i]
		dist := sqDist(offset)
		if dist < bestDist || (dist == bestDist && winTie(offset, bestOffset)) {
			bestDist = dist
			bestOffset = offset
		}
	}

	if initOffset != bestOffset && validOffsetDistance(bestOffset, maxOffset) {
		pix.xy = jfaEncodeAxisOffsetToSeed(bestOffset.x)
		pix.zw = jfaEncodeAxisOffsetToSeed(bestOffset.y)
	}
	return pix
}

func sqDist(offset ivec2) float {
	fOffset := vec2(offset)
	return fOffset.x*fOffset.x + fOffset.y*fOffset.y
}

func winTie(offset, bestOffset ivec2) bool {
	return (offset.x < bestOffset.x || (offset.x == bestOffset.x && offset.y < bestOffset.y))
}

func validOffsetDistance(offset ivec2, maxOffset int) bool {
	return offset.x*offset.x+offset.y*offset.y <= maxOffset*maxOffset
}

// return 1 instead of 0 when going out of bounds
func imgSrc0AtOrWhite(samplingCoords, origin, maxMinusEpsilon vec2) vec4 {
	insideBounds := min(step(origin, samplingCoords), step(samplingCoords, maxMinusEpsilon))
	outsideBounds := 1.0 - min(insideBounds.x, insideBounds.y)
	return max(imageSrc0UnsafeAt(samplingCoords), vec4(outsideBounds))
}

func jfaComputeOffsetToSeed(pix vec4) ivec2 {
	return ivec2(jfaDecodeAxisOffsetToSeed(pix.xy), jfaDecodeAxisOffsetToSeed(pix.zw))
}

// if pq is vec2(1) (max/unspecified offset), the result will be -32767
func jfaDecodeAxisOffsetToSeed(pq vec2) int {
	const epsilon = 0.001
	hi := int((pq[0] + epsilon) * 255.0)
	lo := int((pq[1] + epsilon) * 255.0)
	magnitude := ((hi & 0x7F) << 8) | lo
	sign := 1 - ((hi >> 7) << 1)
	return sign * magnitude
}

// precondition: already ensured that the offset is representable and within maxOffset bounds
func jfaEncodeAxisOffsetToSeed(offset int) vec2 {
	magnitude := abs(offset)
	negBit := (offset >> 8) & 0x80
	hi := negBit | (magnitude >> 8)
	lo := magnitude & 0xFF
	return vec2(float(hi)/255.0, float(lo)/255.0)
}
