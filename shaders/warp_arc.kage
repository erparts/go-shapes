//kage:unit pixels
package main

var Center vec2

func Fragment(targetCoords vec4, _ vec2, _ vec4, customVAs vec4) vec4 {
	const Pi = 3.14159265359

	srcSize := imageSrc0Size()
	outRadius, samplingWidth := customVAs.x, customVAs.y
	inRadius := outRadius - srcSize.y
	startRads, radsSpan := customVAs.z, customVAs.w

	relCoords := (targetCoords.xy - imageDstOrigin())
	fromCenter := relCoords - Center

	r := length(fromCenter)
	if r < inRadius || r > outRadius {
		discard()
	}
	rads := atan2(fromCenter.y, fromCenter.x)
	if rads < 0.0 {
		rads += 2 * Pi
	}
	deltaRads := rads - startRads
	if deltaRads < 0 {
		deltaRads += 2 * Pi
	}
	if deltaRads > radsSpan {
		discard()
	}

	// compute UV
	uv := vec2(deltaRads/radsSpan, (r-inRadius)/(srcSize.y))
	coords := imageSrc0Origin() + uv*vec2(samplingWidth, srcSize.y)
	coords.x += (srcSize.x - samplingWidth) / 2.0
	return bilinearSampling(coords, vec2(1))
}

// technically, homogeneously weighted bilinear sampling is not accurate
// in this scenario, but doing it properly is too expensive for most
// use-cases of the shader
func bilinearSampling(coords, unit vec2) vec4 {
	tl := imageSrc0At(coords - unit/2.0)
	tr := imageSrc0At(coords + vec2(+unit.x/2.0, -unit.y/2.0))
	bl := imageSrc0At(coords + vec2(-unit.x/2.0, +unit.y/2.0))
	br := imageSrc0At(coords + unit/2.0)
	delta := min(fract(coords+unit/2.0), unit) / unit
	top := mix(tl, tr, delta.x)
	bottom := mix(bl, br, delta.x)
	return mix(top, bottom, delta.y)
}
