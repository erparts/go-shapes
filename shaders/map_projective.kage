//kage:unit pixels
package main

// notice: when no translation nor rotation is used, it's typically
// possible to omit 2 or 3 elements from the homography matrix, which
// would make viable passing it without uniforms

var Homography mat3

func Fragment(targetCoords vec4, _ vec2, _ vec4) vec4 {
	relCoords := targetCoords.xy - imageDstOrigin()
	uvw := Homography * vec3(relCoords, 1.0)
	return imageBiSrc0At(imageSrc0Origin() + (uvw.xy/uvw.z)*imageSrc0Size())
}

func imageBiSrc0At(coords vec2) vec4 {
	percent := vec2(1.0)
	halfPercent := percent / 2.0
	minCoords, maxCoords := getMinMaxSourceCoords()
	_, _ = minCoords, maxCoords
	tl := imageSrc0UnsafeAt(clamp(coords+vec2(-halfPercent.x, -halfPercent.y), minCoords, maxCoords))
	tr := imageSrc0UnsafeAt(clamp(coords+vec2(+halfPercent.x, -halfPercent.y), minCoords, maxCoords))
	bl := imageSrc0UnsafeAt(clamp(coords+vec2(-halfPercent.x, +halfPercent.y), minCoords, maxCoords))
	br := imageSrc0UnsafeAt(clamp(coords+vec2(+halfPercent.x, +halfPercent.y), minCoords, maxCoords))
	delta := min(fract(coords+vec2(+halfPercent.x, +halfPercent.y)), percent) / percent
	top := mix(tl, tr, delta.x)
	bottom := mix(bl, br, delta.x)
	return mix(top, bottom, delta.y)
}

func getMinMaxSourceCoords() (vec2, vec2) {
	const epsilon = 0.001 // high epsilon for f16 compatibility
	origin := imageSrc0Origin()
	return origin, origin + imageSrc0Size() - vec2(epsilon)
}
